import cmath
import numpy as np
from itertools import islice , chain

def polyEval( A , x ):
    result = 0
    for j in range(len(A)):
        result += (A[j])*((x)**j)
    return result

def getOmega( n ):
    return np.exp( (2*np.pi*np.complex(0,1)) / n )

def FFT( A ):
    w = getOmega(len(A))
    return FFTlocal( A , w )

def FFTlocal( A , w ):
    if len(A) == 1:
        return A
    n = len(A)
    Ae = FFTlocal( A[0::2] , w**2 )
    Ao = FFTlocal( A[1::2] , w**2 )
    r = [np.complex(0,0)] * len(A)
    for j in range( int((n/2)) ):
        print(Ae[j], Ao[j])
        r[j] = ((Ae[j] + (w**j)*Ao[j]))
        r[j + int(n/2)] = ((Ae[j] - (w**j)*Ao[j]))
    return r

def invFFT( x ):
    # reals = [np.real(a)*(1/4) for a in x]
    # imags = [np.imag(a)*(1/4) for a in x]
    # reals1 = [reals[0]] + reals[-1:1:-1]
    # imags1 = [imags[0]] + imags[-1:1:-1]
    # return [np.complex(r,i) for (r,i) in zip(reals1, imags1)]
    mapReal = map( lambda x: np.real(x)*(1/4) , x )
    mapImag = map( lambda x: np.imag(x)*(1/4) , x )
    firstReal = islice( mapReal, 1 )
    firstImag = islice( mapImag, 1 )
    revReal = reversed( list(islice( mapReal , 1 , None )) )
    revImag = reversed( list(islice( mapImag , 1 , None )) )
    compReal = chain( firstReal , revReal )
    compImag = chain( firstImag , revImag )
    complxList = map( np.complex , compReal , compImag )
    return FFT(list(complxList))

def SFT( A ):
    n = len(A)
    w = getOmega( n )
    res = []
    for j in range( n ):
        res.append( round( polyEval( A , w**j ) , 5 ) )
    return res





def main():
    res = FFT([2,4,5,6])
    print(res)
    print( invFFT(res) )

if __name__ == "__main__":

    main()