import cmath
import numpy as np
from itertools import islice , chain

def polyEval( A , x ):
    result = 0
    for j in range(len(A)):
        result += (A[j])*((x)**j)
    return result

def getOmega( n ):
    return np.exp( (2*np.pi*np.complex(0,1)) / n )

def FFT( A ):
    w = getOmega(len(A))
    return FFTlocal( A , w )

def FFTlocal( A , w ):
    if len(A) == 1:
        return A
    n = len(A)
    Ae = FFTlocal( A[0::2] , w**2 )
    Ao = FFTlocal( A[1::2] , w**2 )
    r = [np.complex(0,0)] * len(A)
    for j in range( int((n/2)) ):
        r[j] = ((Ae[j] + (w**j)*Ao[j]))
        r[j + int(n/2)] = ((Ae[j] - (w**j)*Ao[j]))
    return [round(this,5) for this in r]

def invFFT( x ):
    reals = [np.real(a)*(1/4) for a in x]
    reals1 = reals[::-1]
    realcar = reals1.pop()
    reals1.insert(0,realcar)
    print(reals1)
    imags = [np.imag(a)*(1/4) for a in x]
    imags1 = imags[::-1]
    imagscar = imags.pop()
    imags1.insert(0,imagscar)
    return FFT([np.complex(r,i) for (r,i) in zip(reals1, imags1)])
    
def SFT( A ):
    n = len(A)
    w = getOmega( n )
    res = []
    for j in range( n ):
        res.append( round( polyEval( A , w**j ) , 5 ) )
    return res





def main():
    res = FFT([2,4,5,6])
    print(res , 'res in main')
    print( invFFT(res) )

if __name__ == "__main__":

    main()